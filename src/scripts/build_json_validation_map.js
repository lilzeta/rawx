// the mish/source/validator strat
// https://2ality.com/2020/01/typing-objects-typescript.html#members-of-interfaces-and-object-literal-types
const { writeFile, mkdirSync, existsSync, readFileSync } = require("fs");
const { resolve, join } = require("path");
const { inspect } = require("util");
// const array_rules: Record<str, any> = {
//     one_of_into: [{ of: ["procs", "proc"], into: "procs" }],
//     to_arr_if_not: ["procs"],
//     exit_delay: 50,
//     // pulse: 400,
// };
const rules_location = resolve(".", "src", "ops", "validation", "rules");
console.log(rules_location);
const rule_key_paths = [
    ["server", "manual_server_rules.json"],
    ["watch", "manual_watch_rules.json"],
    ["procs", "manual_procs_rules.json"],
];
const missing = [];
let key_paths_that_exist = [];
for (const [, [key, file_name]] of Object.entries(rule_key_paths)) {
    console.log(file_name);
    const path = join(rules_location, file_name);
    if (!existsSync(path)) missing.push(path);
    else key_paths_that_exist.push([key, path]);
}
if (missing.length) throw new Error(`Missing paths - [${missing.join(", ")}]`);
const rule_dicts = {};
for (const [, [key, full_path]] of Object.entries(key_paths_that_exist)) {
    console.log(`full_path: ${full_path}`);
    rule_dicts[key] = JSON.parse(readFileSync(full_path, "utf8"));
}
console.log(inspect(rule_dicts, { compact: true, depth: 5 }));
// process.exit(1);
// ?
// ? https://stackoverflow.com/questions/32167593/how-to-do-runtime-type-casting-in-typescript

// This file autogenerates basis VALUE typings from instantiated class objects
// It's a specials types of special ...innit, i don't know what schema means >.<`
const Server = require("../../dist/node-only/server.js");
const Watch = require("../../dist/node-only/watch");
// Fake a realz server class to provide a set of base properties
const a_server = new Server({
    dry_run: true,
    procs: [
        {
            type: "exec",
            command: "nothing",
            // type: Type;
            // chain_exit?: "success" | true;
            chain_next: 0,
            chain_failure: 0,
            on_watch: true,
            run_if_file_dne: ".",
            goto_on_file_exists: 2,
            // concurrent: P.A_Proc_Arg;
            delay: 1500,
            trap: true,
            silence: "all",
        },
    ],
});
const a_watch = new Watch({
    paths: ["."],
    poll: 3000,
});
// skip any prop for/w starts with _
const skips = (prop_name) => /^_/.exec(prop_name);
const get_dict = (a_class, rules) => {
    let dict = {
        _notice: "autogenerated file @./src/scripts/build_json_validation_map.js",
    };
    const num_rules = rules.number;
    const str_rules = rules.string;
    const arr_rules = rules.Array;
    const obj_rules = rules.object;
    if (rules["no_intersect"] !== undefined) dict["no_intersect"] = rules["no_intersect"];
    if (rules["no_layer_split_or_intersect"] !== undefined)
        dict["no_layer_split_or_intersect"] = rules["no_layer_split_or_intersect"];
    for (const [key, val] of Object.entries(a_class)) {
        if (skips(key)) continue;
        console.log(`key, val`);
        console.log(key, val);
        const type_of = typeof val;
        if (type_of !== "function" && type_of !== "undefined") {
            dict[key] = {
                type: type_of,
            };
            if (type_of === "object") {
                // for now also |& Array.isArray...
                if (Array.isArray(val)) {
                    if (arr_rules.map_from[key] !== undefined) {
                        dict[key].map_to_array_from = arr_rules.map_from[key];
                    }
                } else {
                    if (obj_rules.keys[key] !== undefined) {
                        dict[key].keys[key] = obj_rules.keys[key];
                    }
                    if (obj_rules.format_for_env[key] !== undefined) {
                        dict[key].format_for_env[key] = obj_rules.format_for_env[key];
                    }
                    if (obj_rules.recurse[key]) {
                        dict[key].recurse[key] = obj_rules.recurse[key];
                    }
                }
                continue;
            }
            if (type_of === "number" && num_rules?.mins?.[key] !== undefined) {
                dict[key].min = num_rules.mins[key];
            }
            if (type_of === "string" && str_rules?.one_of?.[key] !== undefined) {
                dict[key].one_of = str_rules?.one_of?.[key];
            }
        } else {
            // todo undefined
        }
    }
    return dict;
};

// const server_rules = {
//     mins: {
//         kill_delay: 50,
//         exit_delay: 50,
//         // pulse: 400,
//     },
// };
const server_def_dict = get_dict(a_server, rule_dicts["server"]);
const server_def_json = JSON.stringify(server_def_dict, null, 2);
console.log(`server_def_json:`);
console.log(server_def_json);
// console.log(typeof server_class[key]);

a_watch.set_trigger((_, __) => {});
const watch_rules = {
    mins: {
        delay: 3000,
        poll: 700,
    },
    not_mult: ["trigger_index", "trigger_indices"],
};
// const watch_def_dict = get_dict(a_watch, watch_rules);
// const watch_def_json = JSON.stringify(watch_def_dict, null, 2);
// console.log(`watch_def_json:`);
// console.log(watch_def_json);
// const a_proc = a_server.procs[0];
// const proc_def_dict = get_dict(a_proc, {});
// const proc_def_json = JSON.stringify(proc_def_dict, null, 2);
// console.log(`proc_def_json:`);
// console.log(proc_def_json);
a_server.die();
a_watch.watches_clear();
const cb = (err) => {
    if (err) console.log(err);
};
const f_writer = async (file_path, json_data, _cb) => {
    writeFile(file_path, json_data, cb);
};
const dist_val_dir = resolve("dist", "ops", "validation", "schema");
if (!existsSync(dist_val_dir)) mkdirSync(dist_val_dir);
const src_val_dir = resolve("src", "ops", "validation", "schema");
if (!existsSync(src_val_dir)) mkdirSync(src_val_dir);
// rather will copy ./src/ops/validation/schema => ./dist/ops/validation/schema
f_writer(dist_val_dir + "server_schema.json", server_def_json, () => {});
// f_writer(dist_val_dir + "watch_schema.json", watch_def_json, () => {});
// f_writer(dist_val_dir + "proc_schema.json", proc_def_json, () => {});
f_writer(src_val_dir + "server_schema.json", server_def_json, () => {});
// f_writer(src_val_dir + "watch_schema.json", watch_def_json, () => {});
// f_writer(src_val_dir + "proc_schema.json", proc_def_json, () => {});
